/*
	1. Create a stored procedure called 'sp_Tristan_GetCompressorSubmissionStatus' that accepts three parameters: @CompressorID, @Year and @Month (all are INT).

	The result set must list all days of the specified month and year and determine if day has a submitted entry for the specified compressor.
	Example: @CompressorID = 1, @Month = 10, @Year = 2022

	Compressor		Day		HasEntry
	TestComp1		1		No
	TestComp1		2		No
	TestComp1		3		No
	TestComp1		4		Yes
	TestComp1		5		No
	TestComp1		6		No
	TestComp1		7		Yes
	TestComp1		8		No
*/
--creating a temporary table
CREATE TABLE #SubmissionTable (
    SubmissionID INT PRIMARY KEY,
    CompressorID INT,
    SubmissionDate DATE
    -- Add other columns as needed
);

-- Insert sample data into the temporary table
INSERT INTO #SubmissionTable (SubmissionID, CompressorID, SubmissionDate)
VALUES
    (1, 1, '2022-10-04'),
    (2, 1, '2022-10-07'),
    (3, 1, '2022-10-11'),
    (4, 2, '2023-05-05'),
    (5, 2, '2023-05-07');

--Checking the temp table
SELECT * FROM #SubmissionTable;

/*
Purpose: Defines a stored procedure sp_Tristan_GetCompressorSubmissionStatus to fetch submission status for a specified compressor (@CompressorID) in a given month (@Month) and year (@Year).
Usage:
	DateRange CTE (WITH DateRange AS ...): Generates a series of dates (DateValue) for each day of the specified month and year.
Main Query:
	Constructs the Compressor column using @CompressorID.
	Extracts the day of each DateValue using DAY(dr.DateValue).
	Uses a CASE statement to check if a submission exists for each day (dr.DateValue) in #SubmissionTable for the specified @CompressorID.
	If a submission exists (EXISTS condition), sets HasEntry to 'Yes'; otherwise, 'No'.
OPTION (MAXRECURSION 0): Ensures the recursive CTE (DateRange) can run indefinitely, accommodating all days in the month without limit.
*/
CREATE PROCEDURE sp_Tristan_GetCompressorSubmissionStatus
    @CompressorID INT,
    @Year INT,
    @Month INT
AS
BEGIN
    SET NOCOUNT ON;

    -- Generate all days of the specified month and year
    WITH DateRange AS (
        SELECT DATEFROMPARTS(@Year, @Month, 1) AS DateValue
        UNION ALL
        SELECT DATEADD(DAY, 1, DateValue)
        FROM DateRange
        WHERE DATEADD(DAY, 1, DateValue) < DATEADD(MONTH, 1, DATEFROMPARTS(@Year, @Month, 1))
    ),
    NumberedDateRange AS (
        SELECT 
            DateValue,
            ROW_NUMBER() OVER (ORDER BY DateValue) AS RowNum
        FROM DateRange
    )

    -- Query to determine submission status for each day
    SELECT TOP 8
        'TestComp' + CAST(@CompressorID AS VARCHAR) AS Compressor,
        DAY(ndr.DateValue) AS Day,
        CASE 
            WHEN EXISTS (
                SELECT 1 
                FROM #SubmissionTable 
                WHERE CompressorID = @CompressorID 
                AND CAST(SubmissionDate AS DATE) = ndr.DateValue
            ) THEN 'Yes'
            ELSE 'No'
        END AS HasEntry
    FROM 
        NumberedDateRange ndr
    WHERE ndr.RowNum <= 8
    OPTION (MAXRECURSION 0); -- Ensure recursion is not limited (infinite recursion if necessary)
END

--Testing and execution statements
SELECT * 
FROM sys.procedures 
WHERE name = 'sp_Tristan_GetCompressorSubmissionStatus';

EXEC sp_Tristan_GetCompressorSubmissionStatus @CompressorID = 1, @Month = 10, @Year = 2022;

DROP PROCEDURE IF EXISTS sp_Tristan_GetCompressorSubmissionStatus;

/*Explanation:
	
	SELECT DATEFROMPARTS(@Year, @Month, 1) AS DateValue
		Purpose: This part of the CTE creates the starting date (DateValue), which is the first day of the specified month and year.
		Example: If @Year is 2022 and @Month is 10 (October), this query returns 2022-10-01. 


________________________________________________________________
NumberedDateRange AS (
    SELECT 
        DateValue,
        ROW_NUMBER() OVER (ORDER BY DateValue) AS RowNum
    FROM DateRange
)

Purpose: Adds row numbers to the dates generated by DateRange.
ROW_NUMBER() OVER (ORDER BY DateValue) AS RowNum:
	The ROW_NUMBER() function assigns a unique sequential integer to each row within the result set.
	ORDER BY DateValue ensures that row numbers are assigned in chronological order.
________________________________________________________________

________________________________________________________________
WHERE ndr.RowNum <= 8:
	This condition filters the rows to include only the first 8 entries based on the row numbers assigned by the ROW_NUMBER() function.
	ndr.RowNum refers to the row number assigned in the NumberedDateRange CTE.
________________________________________________________________

________________________________________________________________
    SELECT TOP 8
        'TestComp' + CAST(@CompressorID AS VARCHAR) AS Compressor,
        DAY(ndr.DateValue) AS Day,
        CASE 
            WHEN EXISTS (
                SELECT 1 
                FROM #SubmissionTable 
                WHERE CompressorID = @CompressorID 
                AND CAST(SubmissionDate AS DATE) = ndr.DateValue
            ) THEN 'Yes'
            ELSE 'No'
        END AS HasEntry
    FROM 
        NumberedDateRange ndr
    WHERE ndr.RowNum <= 8
    OPTION (MAXRECURSION 0);

'TestComp' + CAST(@CompressorID AS VARCHAR) AS Compressor,
	This creates a string that represents the compressor name by concatenating 'TestComp' with the @CompressorID parameter.
	Example: If @CompressorID is 1, the resulting string will be 'TestComp1'.

"DAY(dr.DateValue) AS Day"
	DAY(dr.DateValue) extracts the day part from the DateValue.
	This represents the day of the month for each date in the DateRange CTE.
	Example: If DateValue is '2022-10-04', DAY('2022-10-04') returns 4.

CASE Statement:
	This checks if there is an existing submission entry for each day for the specified compressor.

CASE WHEN EXISTS (...) THEN 'Yes' ELSE 'No' END AS HasEntry:
	EXISTS is used to check if any row matches the condition inside the subquery.
	If a matching row exists, it returns 'Yes'.
	Otherwise, it returns 'No'.
________________________________________________________________

________________________________________________________________
SELECT 1 
FROM #SubmissionTable 
WHERE CompressorID = @CompressorID 
AND CAST(SubmissionDate AS DATE) = dr.DateValue"


This subquery checks if there is any entry in #SubmissionTable that matches the specified @CompressorID and dr.DateValue.

SELECT 1: 
	The value 1 is a placeholder; it doesn't matter what is selected, as EXISTS only checks for the presence of rows.

Where CompressorID = @CompressorID: 
		Ensures the row belongs to the specified compressor.

CAST(SubmissionDate AS DATE) = dr.DateValue: 
	Compares the SubmissionDate with the current date from DateRange
________________________________________________________________

*/

/*
	2. Create a stored procedure called 'sp_Tristan_GetCompressorDataPointReadingChanges' that accepts one parameter: @CompressorID (INT)

	Based on the submitted entries, the result set should return CompressorName, data point's name, entry date, data point's reading, data point's previous entry reading and the reading change differences
	Must only include data points that only accepts numeric values (Data point type 'Engine Data'  and 'Compressor Data'). The result set should be sorted by data point then by entry date.
	Example: @CompressorID = 1

	CompressorName		DataPoint		EntryDate		Reading		PreviousReading		DiffChanges
	TestComp1			RPM				2022-09-10		1500		0					1500
	TestComp1			RPM				2022-10-04		1500		1500				0
	TestComp1			RPM				2022-10-07		1			1500				-1499
	TestComp1			RPM				2023-02-13		99			1					98
	TestComp1			Min RPM			2022-09-10		3500		0					3500
	TestComp1			Min RPM			2022-10-04		40			3500				-3460
	TestComp1			Min RPM			2022-10-07		4000		40					3960
	TestComp1			Min RPM			2023-02-13		2500		4000				-1500

	Hint: Keep in mind the previous reading should reset between each data point
*/

CREATE PROCEDURE sp_Tristan_GetCompressorDataPointReadingChanges
    @CompressorID INT
AS
BEGIN
    SET NOCOUNT ON;

    WITH DataPointsCTE AS (
        SELECT 
            c.CompressorName,
            dp.Name AS DataPoint,
            ceh.RecordDate AS EntryDate,
            TRY_CAST(ced.Reading AS INT) AS Reading, -- Convert Reading to INT if possible
            COALESCE(LAG(TRY_CAST(ced.Reading AS INT)) OVER (PARTITION BY dp.ID ORDER BY ceh.RecordDate), 0) AS PreviousReading,
            TRY_CAST(ced.Reading AS INT) - COALESCE(LAG(TRY_CAST(ced.Reading AS INT)) OVER (PARTITION BY dp.ID ORDER BY ceh.RecordDate), 0) AS DiffChanges
        FROM dbo.Compressor c
        JOIN dbo.DataPoint dp ON c.ID = dp.CompressorID
        JOIN dbo.DataPointType dpt ON dp.DataPointTypeID = dpt.ID
        JOIN dbo.CompressorEntryDetail ced ON dp.ID = ced.DataPointID
        JOIN dbo.CompressorEntryHeader ceh ON ced.CompressorEntryHeaderID = ceh.ID
        WHERE c.ID = @CompressorID
          AND dpt.Name IN ('Engine Data', 'Compressor Data') -- Numeric data points only
          AND dp.Name IN ('RPM', 'Min RPM') -- Filter for specific data points
          AND TRY_CAST(ced.Reading AS INT) <> 0 -- Exclude entries where Reading is 0 or non-numeric
    )
    SELECT 
        CompressorName,
        DataPoint,
        EntryDate,
        Reading,
        PreviousReading,
        DiffChanges
    FROM DataPointsCTE
    ORDER BY 
        CASE WHEN DataPoint = 'RPM' THEN 1 ELSE 2 END, -- Sort RPM first
        EntryDate; -- Then by EntryDate within each group
END

EXECUTE sp_Tristan_GetCompressorDataPointReadingChanges @CompressorID = 1;

Drop procedure if exists sp_Tristan_GetCompressorDataPointReadingChanges

